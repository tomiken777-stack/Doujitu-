import SwiftUI
import AVFoundation
import Speech
import Accelerate
import Combine
import StoreKit
#if canImport(Translation)
import Translation
#endif

// =====================================
// 19Ë®ÄË™ûÂØæÂøú Ë®≠ÂÆö„É¢„Éá„É´
// =====================================
struct LanguageConfig: Identifiable, Hashable {
    let id: String
    let userLangCode: String
    let partnerLangCode: String
    let userASRLocale: String
    let partnerASRLocale: String
    let partnerTTSLocale: String
    let flag: String
}

let availableLanguages: [LanguageConfig] = [
    LanguageConfig(id: "Ëã±Ë™û", userLangCode: "ja", partnerLangCode: "en", userASRLocale: "ja-JP", partnerASRLocale: "en-US", partnerTTSLocale: "en-US", flag: "üá∫üá∏"),
    LanguageConfig(id: "„Éí„É≥„Éá„Ç£„ÉºË™û", userLangCode: "ja", partnerLangCode: "hi", userASRLocale: "ja-JP", partnerASRLocale: "hi-IN", partnerTTSLocale: "hi-IN", flag: "üáÆüá≥"),
    LanguageConfig(id: "‰∏≠ÂõΩË™û(Á∞°‰ΩìÂ≠ó)", userLangCode: "ja", partnerLangCode: "zh-Hans", userASRLocale: "ja-JP", partnerASRLocale: "zh-CN", partnerTTSLocale: "zh-CN", flag: "üá®üá≥"),
    LanguageConfig(id: "‰∏≠ÂõΩË™û(ÁπÅ‰ΩìÂ≠ó)", userLangCode: "ja", partnerLangCode: "zh-Hant", userASRLocale: "ja-JP", partnerASRLocale: "zh-TW", partnerTTSLocale: "zh-TW", flag: "üáπüáº"),
    LanguageConfig(id: "ÈüìÂõΩË™û", userLangCode: "ja", partnerLangCode: "ko", userASRLocale: "ja-JP", partnerASRLocale: "ko-KR", partnerTTSLocale: "ko-KR", flag: "üá∞üá∑"),
    LanguageConfig(id: "„Éï„É©„É≥„ÇπË™û", userLangCode: "ja", partnerLangCode: "fr", userASRLocale: "ja-JP", partnerASRLocale: "fr-FR", partnerTTSLocale: "fr-FR", flag: "üá´üá∑"),
    LanguageConfig(id: "„Çπ„Éö„Ç§„É≥Ë™û", userLangCode: "ja", partnerLangCode: "es", userASRLocale: "ja-JP", partnerASRLocale: "es-ES", partnerTTSLocale: "es-ES", flag: "üá™üá∏"),
    LanguageConfig(id: "„Éâ„Ç§„ÉÑË™û", userLangCode: "ja", partnerLangCode: "de", userASRLocale: "ja-JP", partnerASRLocale: "de-DE", partnerTTSLocale: "de-DE", flag: "üá©üá™"),
    LanguageConfig(id: "„Ç§„Çø„É™„Ç¢Ë™û", userLangCode: "ja", partnerLangCode: "it", userASRLocale: "ja-JP", partnerASRLocale: "it-IT", partnerTTSLocale: "it-IT", flag: "üáÆüáπ"),
    LanguageConfig(id: "„Éù„É´„Éà„Ç¨„É´Ë™û", userLangCode: "ja", partnerLangCode: "pt", userASRLocale: "ja-JP", partnerASRLocale: "pt-BR", partnerTTSLocale: "pt-BR", flag: "üáßüá∑"),
    LanguageConfig(id: "„É≠„Ç∑„Ç¢Ë™û", userLangCode: "ja", partnerLangCode: "ru", userASRLocale: "ja-JP", partnerASRLocale: "ru-RU", partnerTTSLocale: "ru-RU", flag: "üá∑üá∫"),
    LanguageConfig(id: "„Éô„Éà„Éä„É†Ë™û", userLangCode: "ja", partnerLangCode: "vi", userASRLocale: "ja-JP", partnerASRLocale: "vi-VN", partnerTTSLocale: "vi-VN", flag: "üáªüá≥"),
    LanguageConfig(id: "„Çø„Ç§Ë™û", userLangCode: "ja", partnerLangCode: "th", userASRLocale: "ja-JP", partnerASRLocale: "th-TH", partnerTTSLocale: "th-TH", flag: "üáπüá≠"),
    LanguageConfig(id: "„Ç§„É≥„Éâ„Éç„Ç∑„Ç¢Ë™û", userLangCode: "ja", partnerLangCode: "id", userASRLocale: "ja-JP", partnerASRLocale: "id-ID", partnerTTSLocale: "id-ID", flag: "üáÆüá©"),
    LanguageConfig(id: "„Ç¢„É©„Éì„Ç¢Ë™û", userLangCode: "ja", partnerLangCode: "ar", userASRLocale: "ja-JP", partnerASRLocale: "ar-SA", partnerTTSLocale: "ar-SA", flag: "üá∏üá¶"),
    LanguageConfig(id: "„Éà„É´„Ç≥Ë™û", userLangCode: "ja", partnerLangCode: "tr", userASRLocale: "ja-JP", partnerASRLocale: "tr-TR", partnerTTSLocale: "tr-TR", flag: "üáπüá∑"),
    LanguageConfig(id: "„Ç™„É©„É≥„ÉÄË™û", userLangCode: "ja", partnerLangCode: "nl", userASRLocale: "ja-JP", partnerASRLocale: "nl-NL", partnerTTSLocale: "nl-NL", flag: "üá≥üá±"),
    LanguageConfig(id: "„Éù„Éº„É©„É≥„ÉâË™û", userLangCode: "ja", partnerLangCode: "pl", userASRLocale: "ja-JP", partnerASRLocale: "pl-PL", partnerTTSLocale: "pl-PL", flag: "üáµüá±"),
    LanguageConfig(id: "„Ç¶„ÇØ„É©„Ç§„ÉäË™û", userLangCode: "ja", partnerLangCode: "uk", userASRLocale: "ja-JP", partnerASRLocale: "uk-UA", partnerTTSLocale: "uk-UA", flag: "üá∫üá¶")
]

struct DoujituConfig {
    let appDisplayName: String = "DoujituforJapanese"
    let subscriptionProductID: String = "Doujitu_for_Japanese_monthly"
}

let appConfig = DoujituConfig()

// =====================================
// „É≠„Ç∞Áî®„É¢„Éá„É´
// =====================================
struct ConversationLog: Identifiable {
    let id = UUID()
    let original: String
    let translated: String
    let isUser: Bool
    let timestamp = Date()
}

// =====================================
// TrialUsageStore
// =====================================
@MainActor final class TrialUsageStore: ObservableObject {
    private let limit: Int
    private let usedKey: String
    @Published private(set) var used: Int
    @Published private(set) var remaining: Int
    @Published var isUnlocked: Bool = false

    init(limit: Int = 30, usedKey: String = "DujituforJapanese_trial_used_v1") {
        let saved = UserDefaults.standard.integer(forKey: usedKey)
        let initialUsed = max(0, saved)
        self.limit = limit
        self.usedKey = usedKey
        self.used = initialUsed
        self.remaining = max(0, limit - initialUsed)
    }

    var canUseTranslation: Bool { isUnlocked || remaining > 0 }
    
    func consumeOneIfNeeded() {
        if isUnlocked { return }
        guard remaining > 0 else { return }
        used += 1
        UserDefaults.standard.set(used, forKey: usedKey)
        remaining = max(0, limit - used)
    }
}

// =====================================
// SubscriptionStore
// =====================================
@MainActor final class SubscriptionStore: ObservableObject {
    @Published var product: Product?
    @Published var isSubscribed: Bool = false
    @Published var hasCheckedSubscriptionStatus: Bool = false
    private let productID: String

    init(config: DoujituConfig) {
        self.productID = config.subscriptionProductID
        Task {
            await refresh()
            await observeTransactions()
        }
    }

    func refresh() async {
        do {
            let products = try await Product.products(for: [productID])
            product = products.first
            await updateSubscriptionStatus()
        } catch {
            await updateSubscriptionStatus()
        }
    }

    func purchase() async {
        guard let product else { return }
        do {
            let result = try await product.purchase()
            if case .success(let verification) = result {
                if case .verified(let transaction) = verification {
                    await updateSubscriptionStatus()
                    await transaction.finish()
                }
            }
        } catch { }
    }

    func restore() async {
        try? await AppStore.sync()
        await updateSubscriptionStatus()
    }

    func observeTransactions() async {
        for await result in Transaction.updates {
            if case .verified(let transaction) = result {
                await updateSubscriptionStatus()
                await transaction.finish()
            }
        }
    }

    func updateSubscriptionStatus() async {
        var active = false
        for await result in Transaction.currentEntitlements {
            if case .verified(let transaction) = result, transaction.productID == productID {
                active = true
            }
        }
        isSubscribed = active
        hasCheckedSubscriptionStatus = true
    }
}

// =====================================
// ASRService
// =====================================
final class ASRService: NSObject {
    private var recognizer: SFSpeechRecognizer?
    private let audioEngine = AVAudioEngine()
    private var request: SFSpeechAudioBufferRecognitionRequest?
    private var task: SFSpeechRecognitionTask?
    private var onPartialHandler: ((String)->Void)?
    private var onFinalHandler: ((String)->Void)?
    private var isStarting = false
    private var paused = false
    private var inputTapInstalled = false

    init(localeIdentifier: String) {
        self.recognizer = SFSpeechRecognizer(locale: Locale(identifier: localeIdentifier))
        super.init()
    }

    func updateLocale(_ localeIdentifier: String) {
        self.recognizer = SFSpeechRecognizer(locale: Locale(identifier: localeIdentifier))
    }

    @MainActor func requestAuthorization() async throws {
        let status = await withCheckedContinuation { (cont: CheckedContinuation<SFSpeechRecognizerAuthorizationStatus, Never>) in
            SFSpeechRecognizer.requestAuthorization { cont.resume(returning: $0) }
        }
        if status != .authorized { throw NSError(domain: "ASR", code: 1) }
    }

    @MainActor func startContinuous(onPartial: @escaping (String)->Void, onFinal: @escaping (String)->Void) throws {
        if isStarting { return }
        isStarting = true
        defer { isStarting = false }
        paused = false
        cancelAll()
        onPartialHandler = onPartial
        onFinalHandler = onFinal
        try configureAndStartEngine()
        startRecognitionTask()
    }

    @MainActor func finishInput() {
        if inputTapInstalled {
            audioEngine.inputNode.removeTap(onBus: 0)
            inputTapInstalled = false
        }
        audioEngine.stop()
        request?.endAudio()
    }

    @MainActor func cancelAll() {
        finishInput()
        audioEngine.reset()
        task?.cancel()
        task = nil
        request = nil
    }

    @MainActor private func configureAndStartEngine() throws {
        let session = AVAudioSession.sharedInstance()
        try session.setCategory(.playAndRecord, mode: .measurement, options: [.duckOthers, .defaultToSpeaker])
        try session.setActive(true, options: .notifyOthersOnDeactivation)
        
        let req = SFSpeechAudioBufferRecognitionRequest()
        req.shouldReportPartialResults = true
        if recognizer?.supportsOnDeviceRecognition == true { req.requiresOnDeviceRecognition = true }
        self.request = req
        
        let input = audioEngine.inputNode
        let fmt = input.outputFormat(forBus: 0)
        input.installTap(onBus: 0, bufferSize: 1024, format: fmt) { buffer, _ in req.append(buffer) }
        inputTapInstalled = true
        audioEngine.prepare()
        try audioEngine.start()
    }

    @MainActor private func startRecognitionTask() {
        guard let req = self.request else { return }
        task = recognizer?.recognitionTask(with: req) { [weak self] result, error in
            Task { @MainActor in
                if let r = result {
                    let text = r.bestTranscription.formattedString
                    if r.isFinal { self?.onFinalHandler?(text) } else { self?.onPartialHandler?(text) }
                }
                if let nsErr = error as NSError?, nsErr.code == 1101, !(self?.paused ?? true) {
                    self?.softRestart()
                }
            }
        }
    }

    @MainActor private func softRestart() {
        cancelAll()
        Task {
            try? await Task.sleep(nanoseconds: 200_000_000)
            if let ph = onPartialHandler, let fh = onFinalHandler {
                try? startContinuous(onPartial: ph, onFinal: fh)
            }
        }
    }
}

// =====================================
// TTSSpeaker
// =====================================
@MainActor final class TTSSpeaker: NSObject, AVSpeechSynthesizerDelegate {
    private let synth = AVSpeechSynthesizer()
    @Published var isSpeaking = false
    var onFinish: (() -> Void)?

    override init() {
        super.init()
        synth.delegate = self
    }

    func stopImmediately() {
        synth.stopSpeaking(at: .immediate)
        isSpeaking = false
    }

    func speak(_ text: String, locale: String) {
        stopImmediately()
        let session = AVAudioSession.sharedInstance()
        try? session.setCategory(.playback, mode: .default, options: [.duckOthers])
        try? session.overrideOutputAudioPort(.speaker)
        try? session.setActive(true)

        let u = AVSpeechUtterance(string: text)
        u.voice = AVSpeechSynthesisVoice(language: locale)
        u.rate = AVSpeechUtteranceDefaultSpeechRate
        u.volume = 1.0
        isSpeaking = true
        synth.speak(u)
    }

    nonisolated func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didFinish utterance: AVSpeechUtterance) {
        Task { @MainActor in
            self.isSpeaking = false
            self.onFinish?()
        }
    }
}

// =====================================
// ViewModel
// =====================================
@MainActor final class DoujituVM: ObservableObject {
    @Published var selectedLanguage: LanguageConfig = availableLanguages[0] {
        didSet { updateConfigForSelectedLanguage() }
    }
    
    @Published var enLivePartial: String = ""
    @Published var jaFromEN: String = ""
    @Published var partialJA: String = ""
    @Published var enFromJA: String = ""
    @Published var isRecordingJA = false
    @Published var isTranslating = false
    @Published var logs: [ConversationLog] = []

    var shareText: String {
        logs.map { log in
            let prefix = log.isUser ? "„ÄêÁßÅ„Äë" : "„ÄêÁõ∏Êâã„Äë"
            return "\(prefix)\nÂéüÊñá: \(log.original)\nÁøªË®≥: \(log.translated)"
        }.joined(separator: "\n\n")
    }

    var asrPartner: ASRService
    var asrJA: ASRService
    let tts = TTSSpeaker()
    private let trialStore: TrialUsageStore

    #if canImport(Translation)
    @Published var tConfigJAtoEN: TranslationSession.Configuration?
    @Published var tConfigENtoJA: TranslationSession.Configuration?
    private var sessionJAtoEN: TranslationSession?
    private var sessionENtoJA: TranslationSession?
    #endif // canImport(Translation)

    init(trialStore: TrialUsageStore) {
        self.trialStore = trialStore
        self.asrPartner = ASRService(localeIdentifier: availableLanguages[0].partnerASRLocale)
        self.asrJA = ASRService(localeIdentifier: "ja-JP")
        
        tts.onFinish = { [weak self] in
            Task { await self?.startENContinuous() }
        }
        updateConfigForSelectedLanguage()
    }

    private func updateConfigForSelectedLanguage() {
        asrPartner.cancelAll()
        asrPartner.updateLocale(selectedLanguage.partnerASRLocale)
        jaFromEN = ""
        enFromJA = ""
        enLivePartial = ""
        
        #if canImport(Translation)
        tConfigJAtoEN = .init(source: .init(identifier: "ja"), target: .init(identifier: selectedLanguage.partnerLangCode))
        tConfigENtoJA = .init(source: .init(identifier: selectedLanguage.partnerLangCode), target: .init(identifier: "ja"))
        #endif
        
        Task { await startENContinuous() }
    }
    
    func addToLog(original: String, translated: String, isUser: Bool) {
        let newLog = ConversationLog(original: original, translated: translated, isUser: isUser)
        self.logs.append(newLog)
    }

    func clearLogs() {
        self.logs.removeAll()
    }

    func startENContinuous() async {
        guard trialStore.canUseTranslation else { return }
        do {
            try await asrPartner.requestAuthorization()
            try asrPartner.startContinuous(onPartial: { [weak self] text in
                self?.enLivePartial = text
                self?.translateENtoJA(text, isFinal: false)
            }, onFinal: { [weak self] text in
                self?.translateENtoJA(text, isFinal: true)
            })
        } catch { }
    }

    private func translateENtoJA(_ text: String, isFinal: Bool) {
        guard !text.isEmpty else { return }
        #if canImport(Translation)
        Task {
            guard let s = sessionENtoJA else { return }
            do {
                let res = try await s.translate(text)
                self.jaFromEN = res.targetText
               
                if let lastIndex = self.logs.indices.last, !self.logs[lastIndex].isUser {
                    self.logs[lastIndex] = ConversationLog(original: text, translated: res.targetText, isUser: false)
                } else {
                    self.addToLog(original: text, translated: res.targetText, isUser: false)
                }

                if isFinal { trialStore.consumeOneIfNeeded() }
            } catch { }
        }
        #endif // canImport(Translation)
    }

    func startRecordingJA() async {
        isRecordingJA = true
        asrPartner.cancelAll()
        tts.stopImmediately()
        do {
            try await asrJA.requestAuthorization()
            try asrJA.startContinuous(onPartial: { self.partialJA = $0 }, onFinal: { self.partialJA = $0 })
        } catch { isRecordingJA = false }
    }

    func finishAndTranslateJA() {
        asrJA.finishInput()
        isRecordingJA = false
        Task {
            try? await Task.sleep(nanoseconds: 500_000_000)
            await runJAtoEN(partialJA)
        }
    }

    private func runJAtoEN(_ text: String) async {
        guard !text.isEmpty && trialStore.canUseTranslation else { return }
        isTranslating = true
        #if canImport(Translation)
        if let s = sessionJAtoEN {
            do {
                let res = try await s.translate(text)
                enFromJA = res.targetText
                trialStore.consumeOneIfNeeded()
                tts.speak(res.targetText, locale: selectedLanguage.partnerTTSLocale)
                addToLog(original: text, translated: res.targetText, isUser: true)
            } catch { }
        }
        #endif // canImport(Translation)
        isTranslating = false
    }

    #if canImport(Translation)
    func bindSessionJAtoEN(_ s: TranslationSession) { sessionJAtoEN = s }
    func bindSessionENtoJA(_ s: TranslationSession) { sessionENtoJA = s }
    #endif
}

// =====================================
// UI: „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥‰ªò„ÅçÈå≤Èü≥„Éú„Çø„É≥
// =====================================
struct MicButton: View {
    let isRecording: Bool
    let action: () -> Void
    @State private var pulse: CGFloat = 1.0
    var body: some View {
        ZStack {
            if isRecording {
                Circle()
                    .stroke(Color.red.opacity(0.5), lineWidth: 4)
                    .scaleEffect(pulse)
                    .onAppear {
                        withAnimation(.easeInOut(duration: 0.8).repeatForever(autoreverses: true)) {
                            pulse = 1.3
                        }
                    }
            }
            Circle()
                .fill(isRecording ? Color.red : Color.blue)
                .frame(width: 75, height: 75)
                .shadow(radius: 5)
            Image(systemName: "mic.fill")
                .foregroundColor(.white)
                .font(.system(size: 30, weight: .bold))
        }
    }
}

// =====================================
// UI: Â±•Ê≠¥ÁîªÈù¢
// =====================================
struct HistoryView: View {
    @ObservedObject var vm: DoujituVM
    @Environment(\.dismiss) var dismiss
    @State private var showDeleteConfirm = false

    var body: some View {
        NavigationStack {
            ScrollView {
                LazyVStack(spacing: 16) {
                    if vm.logs.isEmpty {
                        Text("Â±•Ê≠¥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì").foregroundColor(.secondary).padding(.top, 50)
                    }
                    ForEach(vm.logs) { log in
                        HStack(alignment: .bottom) {
                            if log.isUser {
                                Spacer()
                                VStack(alignment: .trailing, spacing: 4) {
                                    Text(log.translated).font(.headline).foregroundColor(.white)
                                    Text(log.original).font(.subheadline).foregroundColor(.white.opacity(0.8))
                                }
                                .padding()
                                .background(Color.orange)
                                .cornerRadius(12)
                            } else {
                                VStack(alignment: .leading, spacing: 4) {
                                    Text(log.translated).font(.headline).foregroundColor(.white)
                                    Text(log.original).font(.subheadline).foregroundColor(.white.opacity(0.8))
                                }
                                .padding()
                                .background(Color.blue)
                                .cornerRadius(12)
                                Spacer()
                            }
                        }
                    }
                }
                .padding()
            }
            .navigationTitle("‰ºöË©±Â±•Ê≠¥")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button(role: .destructive) {
                        showDeleteConfirm = true
                    } label: {
                        Image(systemName: "trash")
                        Text("Ê∂àÂéª")
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    HStack {
                        if !vm.logs.isEmpty {
                            ShareLink(item: vm.shareText) {
                                Image(systemName: "square.and.arrow.up")
                                Text("ÂÖ±Êúâ")
                            }
                        }
                        Button("Èñâ„Åò„Çã") { dismiss() }
                    }
                }
            }
            .alert("Â±•Ê≠¥„Çí„Åô„Åπ„Å¶Ê∂àÂéª„Åó„Åæ„Åô„ÅãÔºü", isPresented: $showDeleteConfirm) {
                Button("„Ç≠„É£„É≥„Çª„É´", role: .cancel) { }
                Button("Ê∂àÂéª„Åô„Çã", role: .destructive) { vm.clearLogs() }
            }
        }
    }
}

// =====================================
// View
// =====================================
struct ContentView: View {
    @StateObject var vm: DoujituVM
    @ObservedObject var trialStore: TrialUsageStore
    @State private var showHistory = false
    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                VStack(spacing: 4) {
                    HStack {
                        Text("\(vm.selectedLanguage.flag) \(vm.selectedLanguage.id)").bold()
                        Spacer()
                        Picker("Ë®ÄË™û", selection: $vm.selectedLanguage) {
                            ForEach(availableLanguages) { lang in
                                Text("\(lang.flag) \(lang.id)").tag(lang)
                            }
                        }
                        .pickerStyle(.menu)
                    }
                    HStack(spacing: 15) {
                        Link("„Éó„É©„Ç§„Éê„Ç∑„Éº„Éù„É™„Ç∑„Éº", destination: URL(string: "https://trapezoidal-partridge-6ad.notion.site/Doujitu-2b0ab0596b9880d68f09e3757b41f160?pvs=143")!)
                        Link("Âà©Áî®Ë¶èÁ¥Ñ (EULA)", destination: URL(string: "https://www.apple.com/legal/internet-services/itunes/dev/stdeula/")!)
                        Spacer()
                    }
                    .font(.system(size: 12))
                    .foregroundColor(.orange)
                }
                .padding(.horizontal)
                .padding(.vertical, 8)
                .background(Color(.systemGroupedBackground))

                VStack(spacing: 8) {
                    HStack {
                        Image(systemName: "person.wave.2")
                        Text("\(vm.selectedLanguage.id)„ÇíÊó•Êú¨Ë™û„Å∏").font(.caption).bold()
                        Spacer()
                    }.foregroundColor(.blue)
                    ScrollView {
                        VStack(alignment: .leading, spacing: 10) {
                            Text(vm.enLivePartial).foregroundColor(.secondary).italic()
                            Text(vm.jaFromEN).font(.system(size: 28, weight: .bold)).frame(maxWidth: .infinity, alignment: .center)
                        }
                    }
                }
                .padding()
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .background(Color.blue.opacity(0.06))

                Divider()

                VStack(spacing: 8) {
                    ScrollView {
                        VStack(alignment: .leading, spacing: 10) {
                            Text(vm.partialJA).foregroundColor(.secondary).italic()
                            Text(vm.enFromJA).font(.system(size: 28, weight: .bold)).frame(maxWidth: .infinity, alignment: .center)
                        }
                    }
                    HStack {
                        Spacer()
                        Text("Êó•Êú¨Ë™û„Çí\(vm.selectedLanguage.id)„Å∏").font(.caption).bold()
                        Image(systemName: "bubble.left.and.exclamationmark.bubble.right")
                    }.foregroundColor(.orange)
                    MicButton(isRecording: vm.isRecordingJA, action: {})
                        .simultaneousGesture(DragGesture(minimumDistance: 0)
                            .onChanged { _ in if !vm.isRecordingJA { Task { await vm.startRecordingJA() } } }
                            .onEnded { _ in vm.finishAndTranslateJA() }
                        )
                        .padding(.bottom, 10)
                }
                .padding()
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .background(Color.orange.opacity(0.06))
            }
            .navigationTitle(appConfig.appDisplayName)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button(action: { showHistory = true }) {
                        Image(systemName: "clock.arrow.circlepath")
                        Text("Â±•Ê≠¥")
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Text("ÊÆã \(trialStore.remaining)Âõû").font(.caption).padding(5).background(Color.gray.opacity(0.1)).cornerRadius(5)
                }
            }
            .sheet(isPresented: $showHistory) {
                HistoryView(vm: vm)
            }
            #if canImport(Translation)
            .translationTask(vm.tConfigENtoJA) { session in vm.bindSessionENtoJA(session) }
            .translationTask(vm.tConfigJAtoEN) { session in vm.bindSessionJAtoEN(session) }
            #endif
        }
    }
}

// =====================================
// Root & App
// =====================================
struct RootView: View {
    @EnvironmentObject var subStore: SubscriptionStore
    @EnvironmentObject var trialStore: TrialUsageStore
    @StateObject var vm: DoujituVM
    init(trialStore: TrialUsageStore) {
        _vm = StateObject(wrappedValue: DoujituVM(trialStore: trialStore))
    }
    var body: some View {
        if subStore.hasCheckedSubscriptionStatus {
            if subStore.isSubscribed || trialStore.canUseTranslation {
                ContentView(vm: vm, trialStore: trialStore)
            } else {
                SubscriptionView()
            }
        } else {
            ProgressView("Ê∫ñÂÇô‰∏≠...")
        }
    }
}

struct SubscriptionView: View {
    @EnvironmentObject var subStore: SubscriptionStore
    var body: some View {
        VStack(spacing: 25) {
            Image(systemName: "globe.americas.fill").font(.system(size: 80)).foregroundColor(.blue)
            Text("Doujitu for Japanese").font(.largeTitle).bold()
            Text("ÂÖ®„Å¶„ÅÆÈÄöË®≥Ê©üËÉΩ„Åå‰Ωø„ÅÑÊîæÈ°å„Å´„Å™„Çä„Åæ„Åô„ÄÇ").multilineTextAlignment(.center).padding(.horizontal)
            
            Button(action: { Task { await subStore.purchase() } }) {
                // ‰øÆÊ≠£ÁÆáÊâÄ: ‰æ°Ê†º„ÇíË°®Á§∫
                Text("\(subStore.product?.displayPrice ?? "¬•100") „ÄÄ7Êó•ÈñìÁÑ°Êñô„ÅßË©¶„Åô")
                    .font(.system(size: 24, weight: .black)) // „Åì„Åì„Åß„Çµ„Ç§„Ç∫(24)„Å®Â§™„Åï„ÇíÂ§âÊõ¥ÔºÅ
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(15)
            }.padding(.horizontal)
            
            Button("Ë≥ºÂÖ•„ÇíÂæ©ÂÖÉ") { Task { await subStore.restore() } }.foregroundColor(.secondary)
            
            VStack(spacing: 15) {
                Link("Âà©Áî®Ë¶èÁ¥Ñ (EULA)", destination: URL(string: "https://www.apple.com/legal/internet-services/itunes/dev/stdeula/")!)
                Link("„Éó„É©„Ç§„Éê„Ç∑„Éº„Éù„É™„Ç∑„Éº", destination: URL(string: "https://trapezoidal-partridge-6ad.notion.site/Doujitu-2b0ab0596b9880d68f09e3757b41f160?pvs=143")!)
            }
            .font(.caption)
            .padding(.top, 20)
        }
    }
}

@main
struct DoujituforJapaneseApp: App {
    @StateObject private var subStore = SubscriptionStore(config: appConfig)
    @StateObject private var trialStore = TrialUsageStore()
    
    var body: some Scene {
        WindowGroup {
            // iPadÂØæÂøúÔºöGeometryReader„Çí‰Ωø„Å£„Å¶ÁîªÈù¢„Çµ„Ç§„Ç∫„ÇíÂà∂Âæ°
            GeometryReader { proxy in
                let isPad = UIDevice.current.userInterfaceIdiom == .pad
                // iPhone 14/15 Pro MaxÁõ∏ÂΩì„ÅÆÂπÖ
                let width: CGFloat = isPad ? 430 : proxy.size.width
                
                ZStack {
                    // iPad„ÅÆÂ†¥Âêà„ÅØËÉåÊôØ„ÇíÊöó„Åè„Åó„Å¶ÈõÜ‰∏≠„Åï„Åõ„Çã
                    if isPad {
                        Color.black.ignoresSafeArea()
                    }
                    
                    RootView(trialStore: trialStore)
                        .environmentObject(subStore)
                        .environmentObject(trialStore)
                        .frame(width: width) // ÂπÖ„ÇíÂõ∫ÂÆö
                        .frame(maxWidth: .infinity, maxHeight: .infinity) // ÁîªÈù¢‰∏≠Â§Æ„Å´ÈÖçÁΩÆ
                        .background(Color(.systemBackground)) // „Ç¢„Éó„É™È†òÂüü„ÅÆËÉåÊôØ„ÇíÁ¢∫‰øù
                        .clipped()
                }
            }
        }
    }
}
